---
title: 'API 通用说明'
description: 'API 格式约定、支持的代币和风险评分参考'
---

## 钱包地址格式约定

<div className="bg-gray-50 p-4 rounded-lg border border-gray-200">
  - TRON 钱包地址对字母的 <span className="text-black font-semibold">大小写敏感</span>。
  - ETH 钱包地址使用 <span className="text-black font-semibold">小写</span> 字母。
</div>

## API 格式约定

<Badge type="info" className="bg-blue-500 text-white px-2 py-1 rounded">
加密细节
</Badge>

<div className="bg-gray-50 p-4 rounded-lg border border-gray-200">
所有请求参数必须以 <span className="text-blue-600 font-semibold">JSON 请求体</span> 的形式构建，使用 <span className="text-blue-600 font-semibold">RSA 公钥</span> 加密，并以 <span className="text-blue-600 font-semibold">Base64 编码</span> 的形式提交。加密后的数据应作为 <span className="text-blue-600 font-semibold">data</span> 参数提交。

同时，响应的 <span className="text-blue-600 font-semibold">data</span> 参数也是加密的，开发者需要解密后才能获取明文内容。
</div>

### 请求格式

```json
{
  "data": "EncryptedString"
}
```


### 加密过程

<div className="bg-gray-50 p-4 rounded-lg border border-gray-200">
  - 使用平台提供的 <span className="text-blue-600 font-semibold">RSA 公钥</span> 对请求参数进行加密。
  - 加密后的数据需进行 <span className="text-blue-600 font-semibold">Base64 编码</span>，并作为 <span className="text-blue-600 font-semibold">data</span> 参数提交。
</div>

### 解密过程

<div className="bg-gray-50 p-4 rounded-lg border border-gray-200">
  - 平台接收到加密的 <span className="text-blue-600 font-semibold">data</span> 参数后，会使用对应的私钥进行解密。
  - 返回的响应 <span className="text-blue-600 font-semibold">data</span> 参数同样是加密后的，开发者需使用公钥解密以获得明文。
</div>

---

### Java 加密代码示例

以下是使用 **RSA 公钥** 对数据加密的代码示例：

```java
import javax.crypto.Cipher;
import java.io.ByteArrayOutputStream;
import java.security.KeyFactory;
import java.security.PublicKey;
import java.security.spec.X509EncodedKeySpec;
import java.util.Base64;

public class RSAEncrypt {
    public static String encryptByPublicKeyForOut(String data, String publicKey) throws Exception {
        // 将公钥字符串解码
        X509EncodedKeySpec x509EncodedKeySpec = new X509EncodedKeySpec(Base64.getDecoder().decode(publicKey));
        KeyFactory keyFactory = KeyFactory.getInstance("RSA");
        PublicKey publicK = keyFactory.generatePublic(x509EncodedKeySpec);

        // 初始化加密器
        Cipher cipher = Cipher.getInstance(keyFactory.getAlgorithm());
        cipher.init(Cipher.ENCRYPT_MODE, publicK);

        byte[] dataByte = data.getBytes();
        int inputLen = dataByte.length;
        ByteArrayOutputStream out = new ByteArrayOutputStream();
        int offSet = 0;
        byte[] cache;
        int i = 0;

        // 分段加密
        while (inputLen - offSet > 0) {
            if (inputLen - offSet > 117) {
                cache = cipher.doFinal(dataByte, offSet, 117);
            } else {
                cache = cipher.doFinal(dataByte, offSet, inputLen - offSet);
            }
            out.write(cache, 0, cache.length);
            i++;
            offSet = i * 117;
        }

        byte[] encryptedData = out.toByteArray();
        out.close();

        // 对加密结果进行 Base64 编码
        return Base64.getEncoder().encodeToString(encryptedData);
    }
}
```

### Java 解密代码示例

以下是使用 **RSA 公钥** 对响应数据解密的代码示例：

```java
import javax.crypto.Cipher;
import java.io.ByteArrayOutputStream;
import java.security.KeyFactory;
import java.security.PublicKey;
import java.security.spec.X509EncodedKeySpec;
import java.util.Base64;

public class RSADecrypt {
    public static String decryptByPublicKeyForOut(String data, String publicKey) throws Exception {
        // 将公钥字符串解码
        X509EncodedKeySpec x509EncodedKeySpec = new X509EncodedKeySpec(Base64.getDecoder().decode(publicKey));
        KeyFactory keyFactory = KeyFactory.getInstance("RSA");
        PublicKey publicK = keyFactory.generatePublic(x509EncodedKeySpec);

        // 初始化解密器
        Cipher cipher = Cipher.getInstance(keyFactory.getAlgorithm());
        cipher.init(Cipher.DECRYPT_MODE, publicK);

        byte[] encryptedData = Base64.getDecoder().decode(data);
        int inputLen = encryptedData.length;
        ByteArrayOutputStream out = new ByteArrayOutputStream();
        int offSet = 0;
        byte[] cache;
        int i = 0;

        // 分段解密
        while (inputLen - offSet > 0) {
            if (inputLen - offSet > 128) {
                cache = cipher.doFinal(encryptedData, offSet, 128);
            } else {
                cache = cipher.doFinal(encryptedData, offSet, inputLen - offSet);
            }
            out.write(cache, 0, cache.length);
            i++;
            offSet = i * 128;
        }

        byte[] decryptedData = out.toByteArray();
        out.close();

        // 返回解密后的明文
        return new String(decryptedData);
    }
}
```

### 注意事项

<div className="bg-yellow-50 p-4 rounded-lg border border-yellow-400">

<ul>

<li>

<span className="font-semibold">公钥/私钥管理：</span>
平台会为每个商户分配 <span className="text-blue-600 font-semibold">RSA 公钥</span>，请妥善保存，避免泄露。私钥由平台严格保管，商户无需关心。

</li>


<li>

<span className="font-semibold">Base64 编码：</span>
加密和解密的结果需进行 <span className="text-blue-600 font-semibold">Base64 编解码</span>，确保数据在传输过程中不出问题。

</li>

</ul>

</div>